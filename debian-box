#!/usr/bin/env bash
# Home: https://github.com/odysseyalive/lampready
# This script creates a LAMP stack with a single debian bookworm container.
# Enhanced with host environment verification and direct systemd service generation.
# Customize the information below to suit your needs,
# then run: bash box

# Before you begin:
# Make sure to expose priviledged ports if you need them
# > sudo -i
# > echo "net.ipv4.ip_unprivileged_port_start=0" > /etc/sysctl.d/05-expose-privileged.conf
# > sysctl --system
# > sysctl net.ipv4.ip_unprivileged_port_start=0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # #
HOSTNAME="lampready.com"
SUB_DOMAIN="dev"
PUBLIC_ROOT_PATH="public_html"

HTTP_PORT="80"
SSL_PORT="443"

TIMEZONE="America/Los_Angeles"

PHP_VERSION="8.3" # 7.4, 8.0, 8.1, 8.2, or 8.3
PHP_MAX_EXEC_TIME="600"
PHP_MEM_LIMIT="512M"

# Enhanced security configuration
XDEBUG_ENABLE="0"
XDEBUG_PORT="9003"
XDEBUG_FORCE_DISPLAY_ERRORS="1"
XDEBUG_SCREAM="0"
XDEBUG_DISPLAY_MAX_DATA="2048"
XDEBUG_DISPLAY_MAX_DEPTH="3"
XDEBUG_DISPLAY_MAX_CHILDREN="128"

# Enhanced permission management
CONTAINER_USER="webuser"
CONTAINER_UID="1000"
CONTAINER_GID="1000"

declare -A DB1=(
  [DB_NAME]=""
  [DB_USER]=""
  [DB_PASS]='' # make sure to use single quotes here to compensate for special chars
  [DB_PERM]="ALL"
  [DB_PREFIX]=""                    # e.g. wp_
  [DB_TYPE]="custom"                # custom, wordpress, magento_1, magento_2
  [DB_FILENAME]=""                  # my_db.sql
  [DB_CUSTOM_FUNCTIONS_FILENAME]="" # my_custom_functions.sql
)

# declare -A DB2=(...

## # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Don't edit below this point unless you really want to
# ref: https://hub.docker.com/r/jrei/systemd-debian
IMAGE="docker.io/jrei/systemd-debian:12"

SITE_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
ACTION="${1:-help}"
if [ "$SUB_DOMAIN" != "" ]; then SITE_NAME="${SUB_DOMAIN}.${HOSTNAME}"; else SITE_NAME=$HOSTNAME; fi
MULTI_BOX=0
USE_TMPFS=0
USE_EXTRAS=1

# Get host user information for proper mapping
HOST_UID=$(id -u)
HOST_GID=$(id -g)
HOST_USER=$(whoami)

# # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # functions

# builds the container directory
function build_container_directory {
  message "Building container directory at ${SITE_HOME}/.container ..."
  if [ -d "${SITE_HOME}/.container/log" ]; then
    rm -rf "${SITE_HOME}/.container/log"
  fi
  if [ -d "${SITE_HOME}/.container/mariadb" ]; then
    rm -rf "${SITE_HOME}/.container/mariadb"
  fi
  mkdir -p "${SITE_HOME}/.container/log"
  mkdir -p "${SITE_HOME}/.container/mariadb"
  if [ ! -d "${SITE_HOME}/.container/sites-enabled" ]; then
    mkdir -p "${SITE_HOME}/.container/sites-enabled"
  fi
  if [ ! -d "${SITE_HOME}/${PUBLIC_ROOT_PATH}" ]; then
    mkdir -p "${SITE_HOME}/${PUBLIC_ROOT_PATH}"
    message "It worked!! Please do something about the missing files in ${SITE_HOME}/${PUBLIC_ROOT_PATH}" >"${SITE_HOME}/${PUBLIC_ROOT_PATH}/index.html"
  fi

  # Set proper ownership for mounted directories
  chown -R "${HOST_UID}:${HOST_GID}" "${SITE_HOME}/.container"
  chown -R "${HOST_UID}:${HOST_GID}" "${SITE_HOME}/${PUBLIC_ROOT_PATH}"
}

# build default httpd conf files
function build_default_httpd_conf {
  # default http file
  _http_conf_file=/etc/apache2/sites-enabled/000-default.conf
  echo "<VirtualHost *:${HTTP_PORT}>" >$_http_conf_file
  echo "    ServerAdmin root@${HOSTNAME}" >>$_http_conf_file
  echo "    ServerName ${HOSTNAME}" >>$_http_conf_file
  echo "    ServerAlias ${SUB_DOMAIN}.${HOSTNAME}" >>$_http_conf_file
  echo "    DocumentRoot /var/www/${PUBLIC_ROOT_PATH}" >>$_http_conf_file
  echo "    DirectoryIndex index.php index.html index.htm" >>$_http_conf_file
  echo "    ErrorLog /var/log/apache2/${HOSTNAME}.error.log" >>$_http_conf_file
  echo "    CustomLog /var/log/apache2/${HOSTNAME}.access.log combined" >>$_http_conf_file
  echo "    <Directory \"/var/www\">" >>$_http_conf_file
  echo "         AllowOverride All" >>$_http_conf_file
  echo "         Require all granted" >>$_http_conf_file
  echo "    </Directory>" >>$_http_conf_file
  echo "    <Directory \"/var/www/${PUBLIC_ROOT_PATH}\">" >>$_http_conf_file
  echo "         Options Indexes FollowSymLinks" >>$_http_conf_file
  echo "         AllowOverride All" >>$_http_conf_file
  echo "         Require all granted" >>$_http_conf_file
  echo "    </Directory>" >>$_http_conf_file
  echo "</VirtualHost>" >>$_http_conf_file

  # default https file
  _https_conf_file=/etc/apache2/sites-enabled/000-default-ssl.conf
  echo "<VirtualHost _default_:${SSL_PORT}>" >$_https_conf_file
  echo "    ServerAdmin root@${HOSTNAME}" >>$_https_conf_file
  echo "    ServerName ${HOSTNAME}" >>$_https_conf_file
  echo "    ServerAlias ${SUB_DOMAIN}.${HOSTNAME}" >>$_https_conf_file
  echo "    DocumentRoot /var/www/${PUBLIC_ROOT_PATH}" >>$_https_conf_file
  echo "    DirectoryIndex index.php index.html index.htm" >>$_https_conf_file
  echo "    ErrorLog /var/log/apache2/${HOSTNAME}.ssl-error.log" >>$_https_conf_file
  echo "    CustomLog /var/log/apache2/${HOSTNAME}.ssl-access.log combined" >>$_https_conf_file
  echo "    SSLEngine on" >>$_https_conf_file
  echo "    SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem" >>$_https_conf_file
  echo "    SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key" >>$_https_conf_file
  echo "    <FilesMatch \"\\.(cgi|shtml|phtml|php)$\">" >>$_https_conf_file
  echo "         SSLOptions +StdEnvVars" >>$_https_conf_file
  echo "    </FilesMatch>" >>$_https_conf_file
  echo "    <Directory \"/var/www/cgi-bin\">" >>$_https_conf_file
  echo "         SSLOptions +StdEnvVars" >>$_https_conf_file
  echo "    </Directory>" >>$_https_conf_file
  echo "    <Directory \"/var/www\">" >>$_https_conf_file
  echo "         Options Indexes FollowSymLinks" >>$_https_conf_file
  echo "         AllowOverride All" >>$_https_conf_file
  echo "         Require all granted" >>$_https_conf_file
  echo "    </Directory>" >>$_https_conf_file
  echo "    <Directory \"/var/www/${PUBLIC_ROOT_PATH}\">" >>$_https_conf_file
  echo "         Options Indexes FollowSymLinks" >>$_https_conf_file
  echo "         AllowOverride All" >>$_https_conf_file
  echo "         Require all granted" >>$_https_conf_file
  echo "    </Directory>" >>$_https_conf_file
  echo "</VirtualHost>" >>$_https_conf_file
}

# builds the site image based on the information entered at
# the top of this script
function build_image {
  # clean up dangling images
  buildah rm --all
  podman rmi -f $(podman images --filter "dangling=true" -q --no-trunc) >/dev/null 2>&1

  # clean up anything that might exist in a failed state
  # or left over from a previous session
  if podman images | grep -q "$SITE_NAME"; then
    message "Cleaning up an old image ..."
    podman rm $SITE_NAME >/dev/null 2>&1
    podman rmi "localhost/${SITE_NAME}:private" >/dev/null 2>&1
  fi

  # tools
  _tools="vim dialog apt-utils dumb-init git curl wget software-properties-common mutt lsb-release ca-certificates gnupg sudo"

  # modules
  _modules="nodejs python3 python3-pip ruby"

  _npm_install="curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash; \
        echo \"nvm install v18.20.4\" >> /root/.bashrc; \
        echo \"npm install --location=global --save-dev grunt-cli gulp gulp-cli yarn\" >> /root/.bashrc; \
		"

  # composer
  _composer="curl https://getcomposer.org/composer-stable.phar -o /usr/local/bin/composer; \
        chmod +x /usr/local/bin/composer; \
        echo \"alias composer='env COMPOSER_ALLOW_SUPERUSER=1 composer'\" >> /root/.bashrc; \
        "

  # apache
  _apache="apache2 openssl ssl-cert"

  # Enhanced Apache configuration with proper user mapping
  _apache_config="groupadd -g ${CONTAINER_GID} ${CONTAINER_USER} && \
    useradd -u ${CONTAINER_UID} -g ${CONTAINER_GID} -m -s /bin/bash ${CONTAINER_USER} && \
    a2enmod ssl rewrite headers && \
    sed -i \"/^# Global configuration/a ServerName ${HOSTNAME}\" /etc/apache2/apache2.conf && \
    sed -i \"s@export APACHE_RUN_USER.*@export APACHE_RUN_USER=${CONTAINER_USER}@g\" /etc/apache2/envvars && \
    sed -i \"s@export APACHE_RUN_GROUP.*@export APACHE_RUN_GROUP=${CONTAINER_USER}@g\" /etc/apache2/envvars && \
    sed -i \"s@Listen 80@Listen ${HTTP_PORT}@g\" /etc/apache2/ports.conf && \
    sed -i \"s@Listen 443@Listen ${SSL_PORT}@g\" /etc/apache2/ports.conf && \
    mkdir -p /var/run/apache2 /var/lock/apache2 && \
    chown -R ${CONTAINER_USER}:${CONTAINER_USER} /var/log/apache2 /var/run/apache2 /var/lock/apache2 && \
    chown -R ${CONTAINER_USER}:${CONTAINER_USER} /var/www"

  # openssl - generate self-signed certificate
  _openssl="make-ssl-cert generate-default-snakeoil --force-overwrite; \
        "

  # Mariadb with proper user configuration
  _mariadb="mariadb-server default-mysql-client \
        "

  _mariadb_config="mkdir -p /var/lib/mysql /var/run/mysqld && \
    chown -R ${CONTAINER_USER}:${CONTAINER_USER} /var/lib/mysql /var/run/mysqld && \
    sed -i \"s@^pid-file@#pid-file@g\" /etc/mysql/mariadb.conf.d/50-server.cnf && \
    sed -i \"s@^socket@#socket@g\" /etc/mysql/mariadb.conf.d/50-server.cnf && \
    printf \"\n[client-server]\nsocket=/var/lib/mysql/mysql.sock\n\" >> /etc/mysql/mariadb.conf.d/50-server.cnf && \
    sed -i \"/^\\[mysqld\\]/a socket=/var/lib/mysql/mysql.sock\\ntmpdir=/tmp\\nlc-messages-dir=/usr/share/mysql\\nskip-external-locking\\nquery_cache_limit=1G\\nquery_cache_size=16M\\ninnodb_file_per_table=1\\ninnodb_strict_mode=0\\nsql_mode=''\\ninnodb_large_prefix=1\\ninnodb_log_file_size=256M\\ntmp_table_size=256MB\\nmax_heap_table_size=256MB\\nslow_query_log = 1\\nslow_query_log_file = /var/log/apache2/mariadb-slow.log\\nlong_query_time = 2\\nlog_error=/var/log/apache2/mariadb.log\\nuser=${CONTAINER_USER}\" /etc/mysql/mariadb.conf.d/50-server.cnf && \
    sed -i \"s@^User=mysql@User=${CONTAINER_USER}@g\" /usr/lib/systemd/system/mariadb.service && \
    sed -i \"s@^Group=mysql@Group=${CONTAINER_USER}@g\" /usr/lib/systemd/system/mariadb.service && \
    sed -i \"s@/usr/sbin/mysqld@/usr/sbin/mysqld --user=${CONTAINER_USER}@g\" /usr/lib/systemd/system/mariadb.service; \
		"

  # elasticsearch - Updated for Debian 12
  _elasticsearch="curl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | gpg --dearmor -o /usr/share/keyrings/elastic.gpg; \
        echo \"deb [signed-by=/usr/share/keyrings/elastic.gpg] https://artifacts.elastic.co/packages/7.x/apt stable main\" | tee -a /etc/apt/sources.list.d/elastic-7.x.list; \
        apt-get update; \
        apt-get install -y elasticsearch; \
        "

  # PHP repository setup for Debian using sury.org
  _php_repo="wget -qO /tmp/debsuryorg-archive-keyring.deb https://packages.sury.org/debsuryorg-archive-keyring.deb; \
        dpkg -i /tmp/debsuryorg-archive-keyring.deb; \
        echo \"deb [signed-by=/usr/share/keyrings/deb.sury.org-php.gpg] https://packages.sury.org/php/ \$(lsb_release -sc) main\" > /etc/apt/sources.list.d/sury-php.list; \
        apt-get update; \
        "

  # php packages
  _php="php${PHP_VERSION} php${PHP_VERSION}-bz2 php${PHP_VERSION}-curl \
          php${PHP_VERSION}-gd php${PHP_VERSION}-intl php${PHP_VERSION}-mbstring \
          php${PHP_VERSION}-pspell php${PHP_VERSION}-xml \
          php${PHP_VERSION}-zip php${PHP_VERSION}-imap php${PHP_VERSION}-imagick \
          php${PHP_VERSION}-mysql php${PHP_VERSION}-soap php${PHP_VERSION}-dev \
          php${PHP_VERSION}-memcached php${PHP_VERSION}-xdebug php${PHP_VERSION}-bcmath \
          php${PHP_VERSION}-tidy \
          memcached \
          "

  # php config
  _php_config="sed -i \"s@short_open_tag.*@short_open_tag=On@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@max_execution_time.*@max_execution_time=${PHP_MAX_EXEC_TIME}@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@max_input_vars.*@max_input_vars=10000@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@memory_limit.*@memory_limit=${PHP_MEM_LIMIT}@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@max_input_vars.*@max_input_vars=10000@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@post_max_size.*@post_max_size=16M@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@upload_max_filesize.*@upload_max_filesize=16M@g\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@session.gc_maxlifetime.*@session.gc_maxlifetime=43200\" /etc/php/${PHP_VERSION}/apache2/php.ini; \
        sed -i \"s@short_open_tag.*@short_open_tag=On@g\" /etc/php/${PHP_VERSION}/cli/php.ini; \
        sed -i \"s@max_execution_time.*@max_execution_time=${PHP_MAX_EXEC_TIME}@g\" /etc/php/${PHP_VERSION}/cli/php.ini; \
        sed -i \"s@max_input_vars.*@max_input_vars=10000@g\" /etc/php/${PHP_VERSION}/cli/php.ini; \
        sed -i \"s@memory_limit.*@memory_limit=${PHP_MEM_LIMIT}@g\" /etc/php/${PHP_VERSION}/cli/php.ini; \
        sed -i \"s@post_max_size.*@post_max_size=16M@g\" /etc/php/${PHP_VERSION}/cli/php.ini; \
        sed -i \"s@upload_max_filesize.*@upload_max_filesize=16M@g\" /etc/php/${PHP_VERSION}/cli/php.ini; \
        "

  # postfix config
  _postfix_config="echo \"postfix postfix/mailname string ${SITE_NAME}\" | debconf-set-selections; \
        echo \"postfix postfix/main_mailer_type string 'Internet Site'\" | debconf-set-selections; \
        apt-get install --assume-yes -y postfix mailutils; \
        sed -i \"s@myhostname =.*@myhostname = ${HOSTNAME}@g\" /etc/postfix/main.cf; \
        printf \"smtpd_use_tls = no\\nvirtual_maps = regexp:/etc/postfix/virtual-regexp\\nmaillog_file=/var/log/apache2/mail.log\" >> /etc/postfix/main.cf; \
        printf \"/.+@.+/ root\" > /etc/postfix/virtual-regexp; \
        "

  _xdebug_config="printf \"xdebug.mode=develop,debug\nxdebug.start_with_request=yes\nxdebug.scream=${XDEBUG_SCREAM}\nxdebug.var_display_max_data=${XDEBUG_DISPLAY_MAX_DATA}\nxdebug.var_display_max_depth=${XDEBUG_DISPLAY_MAX_DEPTH}\nxdebug.var_display_max_children=${XDEBUG_DISPLAY_MAX_CHILDREN}\nxdebug.cli_color=1\nxdebug.log='/var/log/apache2/xdebug.log'\nxdebug.force_display_errors=${XDEBUG_FORCE_DISPLAY_ERRORS}\" >> /etc/php/${PHP_VERSION}/apache2/conf.d/20-xdebug.ini; \
        "

  # build the image in docker style
  message "Building a custom image for ${SITE_NAME} with enhanced security..."

  _file="${SITE_HOME}/.container/Dockerfile.${SITE_NAME}"
  echo "FROM ${IMAGE}" >$_file
  echo "LABEL maintainer='bridgesense llc'" >>$_file
  echo "LABEL description='Provides a secure LAMP stack with proper user mapping for PHP development on Debian.'" >>$_file
  echo "LABEL io.k8s.display-name='A Debian 12 secure LAMP stack'" >>$_file

  # Disable IPv6
  echo "RUN echo 'precedence ::ffff:0:0/96 100' >> /etc/gai.conf" >>$_file
  echo "RUN echo 'Acquire::ForceIPv4 \"true\";' > /etc/apt/apt.conf.d/99force-ipv4" >>$_file

  echo "RUN apt-get update -y --fix-missing" >>$_file
  echo "RUN apt-get install -y ${_tools}" >>$_file
  echo "RUN ${_php_repo}" >>$_file
  echo "RUN apt-get install -y ${_apache} ${_mariadb} ${_php}" >>$_file
  echo "RUN apt-get install -y postfix" >>$_file
  echo "RUN ${_openssl}" >>$_file

  # Use enhanced Apache configuration instead of custom build
  echo "RUN ${_apache_config}" >>$_file
  echo "RUN ${_mariadb_config}" >>$_file
  echo "RUN ${_php_config}" >>$_file
  echo "RUN ${_xdebug_config}" >>$_file
  echo "RUN ${_postfix_config}" >>$_file
  echo "RUN ${_elasticsearch}" >>$_file

  # Sodium is included by default in modern PHP versions on Debian, no separate package needed

  if [ $USE_EXTRAS -eq 1 ]; then
    echo "RUN apt-get install -y ${_modules}" >>$_file
    echo "RUN ${_npm_install}" >>$_file
    echo "RUN ${_composer}" >>$_file
  fi

  # set server time
  echo "RUN ln -fs /usr/share/zoneinfo/${TIMEZONE} /etc/localtime" >>$_file

  # Set a sane PATH that includes sbin directories for all users
  echo "ENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" >>$_file

  # Set the default user for the container
  echo "USER ${CONTAINER_USER}" >>$_file

  # Build with verbose output and logging
  message "Building image with enhanced security and user mapping..."
  podman build --progress=plain -t "localhost/${SITE_NAME}:private" -f $_file 2>&1 | tee "${SITE_HOME}/.container/build.log"

  if [ ${PIPESTATUS[0]} -eq 0 ]; then
    message "Image build completed successfully. Build log saved to ${SITE_HOME}/.container/build.log"
  else
    message "Image build failed! Check ${SITE_HOME}/.container/build.log for details"
    echo "Last 50 lines of build log:"
    tail -50 "${SITE_HOME}/.container/build.log"
    exit 1
  fi
}

# cleans the container directory
function clean_container_directory {
  message "Cleaning the container directory: ${SITE_HOME}/.container ..."

  # Remove the entire .container directory if it exists
  if [ -d "${SITE_HOME}/.container" ]; then
    rm -rf "${SITE_HOME}/.container"
    message "Removed entire .container directory"
  else
    message "No .container directory found"
  fi
}

# cleans up the LAMP container
function clean_lamp_container {
  get_state

  if [ $STATE -eq 0 ]; then
    message "stoping LAMP service..."
    systemctl --user stop "container-${SITE_NAME}.service" >/dev/null 2>&1
    systemctl --user disable "container-${SITE_NAME}.service" >/dev/null 2>&1
  fi

  # Adding a check for running container by name, as service check might fail
  if podman container exists $SITE_NAME; then
    message "Stopping container..."
    podman stop $SITE_NAME >/dev/null 2>&1
    message "Removing container..."
    podman rm $SITE_NAME >/dev/null 2>&1
  fi

  if podman image exists "localhost/${SITE_NAME}:private"; then
    message "removing image..."
    podman rmi "localhost/${SITE_NAME}:private" >/dev/null 2>&1
  fi

  if [ -f "${HOME}/.config/systemd/user/container-${SITE_NAME}.service" ]; then
    rm -f "${HOME}/.config/systemd/user/container-${SITE_NAME}.service"
    systemctl --user daemon-reload
    sleep 2
  fi
}

# a mini-man
function display_help {
  echo ""
  echo "Available commands"
  echo "--------------------------------------------------"
  echo "bash box help        displays available commands"
  echo "bash box up          downloads, builds and starts container"
  echo "bash box halt        stops container"
  echo "bash box import      imports database files"
  echo "bash box export      exports database files"
  echo "bash box destroy     halts and destroys all files affiliated with container"
  echo "bash box list        lists all installed images"
  echo "bash box mail        view mail in mail trap"
  echo "bash box mysql       enter mysql prompt"
  echo "bash box ps          list running containers"
  echo "bash box reset       the emergency panic button - see notes below"
  echo "bash box ssh         enter the container commandline"
  echo ""
  echo "ENHANCED SECURITY FEATURES:"
  echo "This script now uses proper user mapping instead of running Apache as root."
  echo "Apache runs on standard ports (${HTTP_PORT}/${SSL_PORT}) directly."
  echo ""
  echo "NOTE ABOUT ROOTLESS CONTAINERS:"
  echo "A feature of the rootless container is the ability to utilize the host"
  echo "system's environment.  This provides an incredible boost in system"
  echo "performance over a traditional VM.  Any limitations discovered in the"
  echo "container are limitations of the host system."
  echo ""
  echo "As an example, if you want to use any of the privileged ports below 1024,"
  echo "you will need to run the following commands on the host system prior to"
  echo "running this script:"
  echo ""
  echo "echo 'net.ipv4.ip_unprivileged_port_start=0' > /etc/sysctl.d/05-expose-privileged.conf"
  echo "sysctl --system"
  echo ""
  echo "In short, any adjusts to kernel runtime parameters are adjustments"
  echo "that need performed on the host system."
  echo ""
  echo "PERMISSION MANAGEMENT:"
  echo "Files created by the container will now have proper ownership matching"
  echo "your host user. The container runs with user mapping:"
  echo "- Container user: ${CONTAINER_USER} (UID: ${CONTAINER_UID})"
  echo "- Host user: ${HOST_USER} (UID: ${HOST_UID})"
  echo ""
  echo "EXPANDING INOTIFY WATCH LIMIT"
  echo "In another example, popular tools like Angular or Gulp can reload and"
  echo "compile code on the fly.  These processes might fail for no reason at all. Increasing the"
  echo "inotify max_user_watches value might help certain situations for larger projects."
  echo ""
  echo "echo 'fs.inotify.max_user_watches=524288' > /etc/sysctl.d/10-increase-inotify-watch-limit.conf"
  echo "sysctl --system"
  echo ""
  echo "ADDING ADDITIONAL HOSTNAMES:"
  echo "To override remote DNS routing any local hostnames need to be defined in the host"
  echo "system's /etc/hosts file manually:"
  echo ""
  echo "echo \"127.0.0.1   dev.lampready.com localhost\" >> /etc/hosts"
  echo ""
  echo "INCLUDING ADDITIONAL APACHE SITE CONFIGURATION FILES:"
  echo "This script is designed to work with the single hostname entered at the"
  echo "top of this file.  Additional site configuration files may be copied to the"
  echo "following directory:"
  echo ""
  echo "mkdir -p .container/sites-enabled"
  echo "cp my_site_config.conf .container/sites-enabled"
  echo ""
  echo "ACCESSING LOG FILES:"
  echo "Log files may be accessed in the following directory after the script"
  echo "has been launched:"
  echo ""
  echo "ls -l .container/logs"
  echo ""
  echo "NOTE ABOUT DESTROYING CONTAINERS:"
  echo "The destroy command will not delete some shared content. The following directories"
  echo "will not be affected:"
  echo ""
  echo "${SITE_HOME}/.container/sites-enabled"
  echo "${SITE_HOME}/${PUBLIC_ROOT_PATH}"
  echo ""
  echo "WHY DO I USE THE RESET OPTION FOR?"
  echo "Don't confuse the reset option with the destroy command. Destroy wipes a project clean."
  echo "Reset wipes out everything you've done with podman. It essentially destroys all projects"
  echo "including the master image, so be careful with it. You might have other projects that are"
  echo "not related to this script that will also be removed."
  echo ""
  echo "From time to time, a reoccurring error appears during the build phase, 'error copying"
  echo "layers and metadata for container'. This error is not based on any dangling processes"
  echo "or bad images. The reset option is just a quick way around the issue, allowing you to"
  echo "move forward quickly in setting up a new project -- at the cost of trashing any existing"
  echo "projects that are working. In most cases, this script doesn't take long spinning up new"
  echo "images. A quick reset is not that much of a disadvantage when considering time and"
  echo "deadlines."
  echo ""
  echo "SECURITY IMPROVEMENTS:"
  echo "This version uses proper user mapping and standard ports for Apache."
  echo ""
  echo "CREDITS:"
  echo "This script was based on Scott McCarty's contribution to this subject,"
  echo "A Hacker's Guide to Moving LInux Services Into Containers:"
  echo ""
  echo "https://crunchtools.com/moving-linux-services-to-containers"
  echo ""
  echo "Enhanced with proper permission handling and security best practices"
  echo "for modern container deployments on Debian 12 (Bookworm)."
  echo ""
}

function export_databases {
  # export database
  for ((i = 1; i < 50; i++)); do
    if set | grep "^DB$i" >/dev/null 2>&1; then
      declare -n var="DB$i"
      if [ "${var[DB_NAME]}" != "" ]; then
        mysqldump -u root --single-transaction --quick --lock-tables=false --skip-tz-utc ${var[DB_NAME]} | gzip -9 >"/var/www/${var[DB_NAME]}.sql.gz"
      fi
    fi
  done
}

# import databases
function import_databases {
  # import database
  for ((i = 1; i < 50; i++)); do
    if set | grep "^DB$i" >/dev/null 2>&1; then
      declare -n var="DB$i"
      if [ "${var[DB_NAME]}" != "" ] && [ "${var[DB_USER]}" != "" ]; then
        # creating database
        mysql -e "CREATE DATABASE ${var[DB_NAME]}" >/dev/null 2>&1

        # creating user
        mysql -e "CREATE USER '${var[DB_USER]}'@'localhost' IDENTIFIED BY '$(echo ${var[DB_PASS]})';" >/dev/null 2>&1

        # granting permissions
        mysql -e "GRANT ${var[DB_PERM]} ON ${var[DB_NAME]}.* TO '${var[DB_USER]}'@'localhost'"

        # importing database file if exists
        if [ "${var[DB_FILENAME]}" != "" ] && [ -f "/var/www/${var[DB_FILENAME]}" ]; then
          mysql -f ${var[DB_NAME]} </var/www/${var[DB_FILENAME]}

          # importing functions if exists
          if [ "${var[DB_CUSTOM_FUNCTIONS_FILENAME]}" != "" ] && [ -f "/var/www/${var[DB_CUSTOM_FUNCTIONS_FILENAME]}" ]; then
            mysql -f ${var[DB_NAME]} </var/www/${var[DB_CUSTOM_FUNCTIONS_FILENAME]}
          fi

          # modifications for development site name designation
          if [ "${var[DB_TYPE]}" == "wordpress" ]; then
            WPQ1=$(mysql -N -e "use ${var[DB_NAME]}; SELECT option_value FROM ${var[DB_PREFIX]}options WHERE option_name = 'siteurl'")
            WPA1=$(sed -E "s@(:\/\/([a-zA-Z0-9\-]*\.)?([a-zA-Z0-9\-]*)\.([a_zA-Z0-9\-]*))(\.[a-zA-Z0-9\-]*)?\/?@://${SITE_NAME}@" <<<$WPQ1)
            mysql -e "USE ${var[DB_NAME]}; UPDATE ${var[DB_PREFIX]}options SET option_value = '${WPA1}' WHERE option_name = 'siteurl' OR option_name = 'home'"
            mysql -e "USE ${var[DB_NAME]}; UPDATE ${var[DB_PREFIX]}posts SET guid = replace(guid, '${WPQ1}','${WPA1}')"
            mysql -e "USE ${var[DB_NAME]}; UPDATE ${var[DB_PREFIX]}posts SET post_content = replace(post_content, '${WPQ1}', '${WPA1}')"
            mysql -e "USE ${var[DB_NAME]}; UPDATE ${var[DB_PREFIX]}postmeta SET meta_value = replace(meta_value,'${WPQ1}','${WPA1}')"
          fi
          if [ "${var[DB_TYPE]}" == "magento_1" ]; then
            echo "Setting up Magento..."
            MGQ1=$(mysql -N -e "use ${var[DB_NAME]}; SELECT value FROM ${var[DB_PREFIX]}core_config_data WHERE scope = 'default' AND path = 'web/unsecure/base_url'")
            MGA1=$(sed -E "s@(:\/\/([a-zA-Z0-9\-]*\.)?([a-zA-Z0-9\-]*)\.([a-zA-Z0-9\-]*))(\.[a-zA-Z0-9\-]*)?\/?@://${SITE_NAME}/@" <<<$MGQ1)
            mysql -e "USE ${var[DB_NAME]}; UPDATE ${var[DB_PREFIX]}core_config_data SET value = '$MGA1' WHERE path = 'web/unsecure/base_url'"
            MGQ2=$(mysql -N -e "use ${var[DB_NAME]}; SELECT value FROM ${var[DB_PREFIX]}core_config_data WHERE scope = 'default' AND path = 'web/secure/base_url'")
            MGA2=$(sed -E "s@(:\/\/([a-zA-Z0-9\-]*\.)?([a-zA-Z0-9\-]*)\.([a-zA-Z0-9\-]*))(\.[a-zA-Z0-9\-]*)?\/?@://${SITE_NAME}/@" <<<$MGQ2)
            mysql -e "USE ${var[DB_NAME]}; UPDATE ${var[DB_PREFIX]}core_config_data SET value = '$MGA2' WHERE path = 'web/secure/base_url'"
            mysql -e "USE ${var[DB_NAME]}; TRUNCATE ${var[DB_PREFIX]}core_cache"
            mysql -e "USE ${var[DB_NAME]}; TRUNCATE ${var[DB_PREFIX]}core_cache_tag"
            mysql -e "USE ${var[DB_NAME]}; TRUNCATE ${var[DB_PREFIX]}core_session"
            cd "/var/www/${PUBLIC_ROOT_PATH}"
            php -f shell/compiler.php -- disable
            php -f shell/indexer.php reindexall
          fi
          if [ "${var[DB_TYPE]}" == "magento_2" ]; then
            cd "/var/www/${PUBLIC_ROOT_PATH}"
            php bin/magento setup:store-config:set --base-url="http://${SITE_NAME}/"
            php bin/magento setup:store-config:set --base-url-secure="https://${SITE_NAME}/"
            php bin/magento setup:static-content:deploy -f
            php bin/magento cache:flush
            php bin/magento indexer:reindex
          fi

        fi
      fi
    else
      break
    fi

    mysql -e "FLUSH PRIVILEGES"
  done
}

# get current state of container
function get_state {
  # 6 = failed validation of minimum requirements for the script
  # 5 = service is running
  # 4 = ready to build file structure
  # 3 = ready to build image
  # 2 = ready to create service
  # 1 = ready to run LAMP service
  # 0 = Lamp Service is Running

  STATE=6
  if [ -x "$(command -v podman)" ]; then
    if systemctl --user is-active --quiet "container-${SITE_NAME}.service" >/dev/null 2>&1; then
      STATE=0
    else
      STATE=4
      if [ -d "${SITE_HOME}/.container" ]; then
        STATE=3
        if podman image exists "localhost/${SITE_NAME}:private"; then
          STATE=2
          if [ -f "${HOME}/.config/systemd/user/container-${SITE_NAME}.service" ]; then
            STATE=1
          fi
        fi
      fi
    fi
  fi
}

# display messages
function message {
  echo ""
  echo "${1}"
}

# warn there is no box running
function no_box_running_message {
  message "The box must be running first!"
  message "Run 'bash box up' to start it"
}

# setup local systemd service
function setup_systemd_service {
  message "Setting up systemd service directly..."

  # create directory if it doesn't exist
  mkdir -p "${HOME}/.config/systemd/user"

  # stop and clean up any old container with the same name
  podman container exists "$SITE_NAME" && podman rm -f "$SITE_NAME"

  # remove the current container file if it exists
  rm -f "${HOME}/.config/systemd/user/container-${SITE_NAME}.service"

  # Create a temporary container from which to generate the service file
  podman create \
    --name "$SITE_NAME" \
    --hostname "$HOSTNAME" \
    --user "${HOST_UID}:${HOST_GID}" \
    --publish "${HTTP_PORT}:${HTTP_PORT}" \
    --publish "${SSL_PORT}:${SSL_PORT}" \
    --publish "${XDEBUG_PORT}:9003" \
    --volume "${SITE_HOME}:/var/www:Z" \
    --volume "${SITE_HOME}/.container/sites-enabled:/etc/apache2/sites-enabled:Z" \
    --volume "${SITE_HOME}/.container/log:/var/log/apache2:Z" \
    --volume "${SITE_HOME}/.container/mariadb:/var/lib/mysql:Z" \
    --security-opt "no-new-privileges" \
    --cap-add "CHOWN,DAC_OVERRIDE,SETGID,SETUID,NET_BIND_SERVICE" \
    --userns=keep-id \
    "localhost/${SITE_NAME}:private"

  # Generate the service file
  podman generate systemd --new --files --name "$SITE_NAME"

  # Move the generated file to the correct systemd user directory
  if [ -f "container-${SITE_NAME}.service" ]; then
    mv "container-${SITE_NAME}.service" "${HOME}/.config/systemd/user/"
    message "Service file created at ${HOME}/.config/systemd/user/container-${SITE_NAME}.service"
  else
    message "❌ ERROR: Failed to generate systemd service file."
    exit 1
  fi

  # Clean up the temporary container
  podman rm -f "$SITE_NAME"
}

# start local systemd service
function start_systemd_service {
  message "Starting enhanced secure services via systemd..."
  systemctl --user daemon-reload
  sleep 2

  # NEW: Verify that systemd sees the unit file now
  if ! systemctl --user list-unit-files | grep -q "container-${SITE_NAME}.service"; then
    message "❌ ERROR: systemd has not recognized the new service file. Please check permissions on ~/.config/systemd/user/"
    exit 1
  fi

  systemctl --user enable --now "container-${SITE_NAME}.service"
}

# # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # routing
if [ "$ACTION" == "help" ]; then
  display_help | less
  exit
fi

# Download, build and start your LAMP with one commandline
if [ "$ACTION" == "up" ]; then
  # NEW: Check for user lingering, which is required for systemd user services
  if ! loginctl show-user "$(whoami)" | grep -q "Linger=yes"; then
    message "❌ ERROR: User lingering is not enabled. Rootless containers managed by systemd require this."
    echo "Please run the following command once to enable it:"
    echo ""
    echo "  sudo loginctl enable-linger $(whoami)"
    echo ""
    exit 1
  fi

  # what is the current script state
  get_state

  # handle validation warning
  if [ $STATE -eq 6 ]; then
    echo ""
    echo "This script is designed to be used with a Linux system built on systemd"
    echo "Please make sure that the following packages are installed:"
    echo ""
    echo "For Debian-based Systems"
    echo "sudo apt install podman buildah catatonit"
    echo ""
    echo "For Red Hat Systems"
    echo "sudo dnf module install -y container-tools:3.0"
    echo ""
    exit 1
  fi

  # Destroy and clean up if things are in a weird state from a previous failed run
  # State 1 is valid (ready to run), so only clean up states 2 and 3
  if [ $STATE -eq 2 ] || [ $STATE -eq 3 ]; then
    message "Detected a previous incomplete state. Cleaning up before proceeding..."
    clean_lamp_container
    get_state
  fi

  # builds the container directory
  if [ $STATE -eq 4 ]; then
    build_container_directory
    get_state
  fi

  # build the image
  if [ $STATE -eq 3 ]; then
    build_image
    get_state
  fi

  if [ $STATE -eq 2 ]; then
    setup_systemd_service
    get_state
  fi

  # ready to launch LAMP server
  if [ $STATE -eq 1 ]; then
    start_systemd_service
    get_state
  fi

  if [ $STATE -eq 0 ] && [ -f "${SITE_HOME}/.container/init.lock" ]; then
    # Startup Services
    sleep 5
    message "Loading Services..."
    podman exec "${SITE_NAME}" /usr/sbin/postfix start
    podman exec "${SITE_NAME}" /usr/bin/memcached -d -u ${CONTAINER_USER} -m 64 -p 11211
    podman exec --user elasticsearch "${SITE_NAME}" /usr/share/elasticsearch/bin/elasticsearch -d
    message "Starting mariadb..."
    podman exec -d "${SITE_NAME}" /usr/bin/mysqld_safe --user=${CONTAINER_USER}
    while ! podman exec "${SITE_NAME}" [ -S /var/lib/mysql/mysql.sock ] && [ $_timeout -lt 15 ]; do
      sleep 2
      let "_timeout+=1"
    done
    # If the socket still doesn't exist, fail with a clear error.
    if ! podman exec "${SITE_NAME}" [ -S /var/lib/mysql/mysql.sock ]; then
      message "❌ MariaDB manual start failed. Check container logs: podman logs ${SITE_NAME}"
      message "Displaying last 20 lines of the MariaDB log from within the container:"
      podman exec "${SITE_NAME}" tail -n 20 /var/log/apache2/mariadb.log
      exit 1
    fi
    podman exec "${SITE_NAME}" ln -s /var/lib/mysql/mysql.sock /var/run/mysqld/mysqld.sock
    message "Starting apache..."
    podman exec "${SITE_NAME}" /usr/sbin/apache2ctl -k start
  fi

  # check if lamp has been initialized
  if [ $STATE -eq 0 ] && [ ! -f "${SITE_HOME}/.container/init.lock" ]; then
    message "Running first-time initialization..."

    # STEP 1: Create Apache config files inside the container.
    # This fixes the original problem.
    message "Creating default Apache configuration files..."
    podman exec "${SITE_NAME}" bash /var/www/box init

    # STEP 2: Manually start and prepare MariaDB.
    # This robust method prevents the service timeouts.
    message "Initializing MariaDB data directory..."
    podman exec "${SITE_NAME}" mysql_install_db --user=${CONTAINER_USER} --basedir=/usr --datadir=/var/lib/mysql

    message "Starting MariaDB server manually for setup..."
    podman exec -d "${SITE_NAME}" /usr/bin/mysqld_safe --user=${CONTAINER_USER}

    message "Waiting for MariaDB socket to become available..."
    _timeout=0
    while ! podman exec "${SITE_NAME}" [ -S /var/lib/mysql/mysql.sock ] && [ $_timeout -lt 15 ]; do
      sleep 2
      let "_timeout+=1"
    done

    # If the socket still doesn't exist, fail with a clear error.
    if ! podman exec "${SITE_NAME}" [ -S /var/lib/mysql/mysql.sock ]; then
      message "❌ MariaDB manual start failed. Check container logs: podman logs ${SITE_NAME}"
      message "Displaying last 20 lines of the MariaDB log from within the container:"
      podman exec "${SITE_NAME}" tail -n 20 /var/log/apache2/mariadb.log
      exit 1
    fi

    # STEP 4: Auxillary Services
    message "Loading Services"
    podman exec "${SITE_NAME}" /usr/sbin/postfix start
    podman exec "${SITE_NAME}" /usr/bin/memcached -d -u ${CONTAINER_USER} -m 64 -p 11211
    podman exec --user elasticsearch "${SITE_NAME}" /usr/share/elasticsearch/bin/elasticsearch -d

    # STEP 5: Import the database now that the server is confirmed to be running.
    message "✅ MariaDB is running. Proceeding with database setup."
    podman exec "${SITE_NAME}" bash /var/www/box import_db
    podman exec "${SITE_NAME}" ln -sf /var/lib/mysql/mysql.sock /var/run/mysqld/mysqld.sock

    # STEP 6: Manually start the Apache service:
    message "Starting Apache service..."
    podman exec "${SITE_NAME}" /usr/sbin/apache2ctl -k start

    # STEP 7: Create the lock file to prevent this from running again.
    # The 'init' action inside the container also creates a lock file,
    # but we create one on the host as the primary check.
    touch "${SITE_HOME}/.container/init.lock"
  fi

  # ready to launch LAMP server
  if [ $STATE -eq 0 ]; then
    echo ""
    echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    echo "+                                                                 +"
    echo "+  Your Enhanced Secure Debian LAMP is ready...                   +"
    echo "+                                                                 +"
    echo "+  Access via:                                                    +"
    echo "+  HTTP:  http://${SITE_NAME}"
    echo "+  HTTPS: https://${SITE_NAME}"
    echo "+                                                                 +"
    echo "+  Add to your hosts file:                                        +"
    echo "+  127.0.0.1   ${SITE_NAME}"
    echo "+                                                                 +"
    echo "+  Xdebug port: ${XDEBUG_PORT}"
    echo "+  Memcached port: 11211                                          +"
    echo "+                                                                 +"
    echo "+  All outbound mail is trapped and can be viewed with:           +"
    echo "+  bash box mail                                                  +"
    echo "+                                                                 +"
    echo "+  See LAMPready.com for more information.                        +"
    echo "+                                                                 +"
    echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
    echo ""
    echo "" && exit >/dev/null 2>&1
  fi
  exit
fi

# Halts the container, stopping all processes associated
# with it.
if [ "$ACTION" == "halt" ]; then
  get_state

  if [ $STATE -eq 0 ]; then
    message "Stopping the container-${SITE_NAME}.service..."
    systemctl --user stop "container-${SITE_NAME}.service"
    podman stop "${SITE_NAME}" >/dev/null 2>&1
    message "${SITE_NAME} has been halted!"
    echo "" && exit >/dev/null 2>&1

  else
    no_box_running_message
  fi
  exit
fi

# Halts and destroys any files created by this container.
if [ "$ACTION" == "destroy" ]; then
  get_state
  clean_lamp_container
  clean_container_directory
  message "Destroy request complete!"
  echo "" && exit >/dev/null 2>&1
fi

# Export databases
if [ "$ACTION" == "export" ]; then
  get_state

  if [ $STATE -eq 0 ]; then
    message "Exporting databases"
    message "Depending on the size of the database(s), this could take some time..."
    podman exec "${SITE_NAME}" bash /var/www/box export_db
    message "Export complete.  Check for *.gz files in ${SITE_HOME}"
    echo "" && exit >/dev/null 2>&1
  else
    no_box_running_message
  fi
  exit
fi

# Import databases
if [ "$ACTION" == "import" ]; then
  get_state
  if [ $STATE -eq 0 ]; then
    message "Depending on the size of the database(s), this could take some time..."
    podman exec "${SITE_NAME}" bash /var/www/box import_db
    echo "" && exit >/dev/null 2>&1
  else
    no_box_running_message
  fi
  exit
fi

# List current images
if [ "$ACTION" == "list" ] || [ "$ACTION" == "ls" ]; then
  podman images
  exit
fi

# View Email Trap
if [ "$ACTION" == "mail" ]; then
  get_state

  if [ $STATE -eq 0 ]; then
    podman exec -it "${SITE_NAME}" bash /var/www/box mutt
    echo "" && exit >/dev/null 2>&1
  else
    no_box_running_message
  fi
  exit
fi

# Enter Mysql Prompt
if [ "$ACTION" == "mysql" ]; then
  get_state

  if [ $STATE -eq 0 ]; then
    podman exec -it "${SITE_NAME}" /usr/bin/mysql
    echo "" && exit >/dev/null 2>&1
  else
    no_box_running_message
  fi
  exit
fi

# List running containers
if [ "$ACTION" == "ps" ]; then
  podman container list
  exit
fi

# emergency reset
if [ $ACTION == "reset" ]; then
  podman images 2>/dev/null
  echo ""
  echo "WARNING! This will destroy all images listed above and their associated containers."
  accept_reset=false
  while true; do
    read -p "Do you wish to continue? (y/n): " yn
    case $yn in
    [Yy]*)
      accept_reset=true
      break
      ;;
    [Nn]*) break ;;
    *) echo "Please answer y or n." ;;
    esac
  done

  if $accept_reset -eq true; then
    get_state
    clean_lamp_container
    clean_container_directory
    podman system prune --all --force
    podman rmi --all --force
    echo ""
    echo "You may need to manually clean any other deployments of this script"
    echo "with 'bash box destroy', or manually remove the .container directory."
    echo ""
    message "Everything has been reset"
  else
    message "nothing happened"
  fi
  echo "" && exit >/dev/null 2>&1
fi

# Enter lamp shell
if [ "$ACTION" == "ssh" ]; then
  get_state

  if [ $STATE -eq 0 ]; then
    podman exec -it "${SITE_NAME}" /bin/bash -l
    echo "" && exit >/dev/null 2>&1
  else
    no_box_running_message
  fi
  exit
fi

# # # # # # # # # # # # # # # # # # # # # # # # # # # #
# This is reserved for box deployment from within the
# container environment.
# export db
if [ "$ACTION" == "export_db" ]; then
  export_databases
  message "Export complete"
  exit
fi

# imports database files
if [ "$ACTION" == "import_db" ]; then
  import_databases
  message "Import complete"
  exit
fi

# builds default httpd files
if [ "$ACTION" == "init" ]; then
  build_default_httpd_conf
  touch "/var/www/.container/init.lock"
  exit
fi

# run mutt without terminal conflicts
if [ "$ACTION" == "mutt" ]; then
  $(which mutt)
fi

message "'bash box ${ACTION}' is not valid."
message "Use 'bash box help' for available commands."
